<p align="center">
  <a href="https://lipsum.com" target="blank"><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/ae6/c62/b55/ae6c62b55a83ba5f2f014751ee973d6e.jpg" width="420" alt="Yes yes yes" /></a>
</p>




## Description

«Всё занимает больше времени, чем вы планировали.» - Дуглас Хофштадтер, американский учёный

## Цель: Выполнить тестовую <a href="https://github.com/kolikosoft/backend-test">вот эту задачу</a>

## Что удалось сделать: Сделал всё что надо и даже чуть-чуть оверхед овердизайнул кажется, реализовал возможность покупки Items и в рамках этой реализации показал как можно обработать транзакции

# Пользователь не может уйти в минус потому что схема базы не позволяет это сделать + истории по депозиту хранятся в отдельной таблице которую нельзя апдейтить или удалять, тоже самое с транзакциями - нельзя удалять. Всё как у взрослых платёжных систем. Это моя специализация. Все вставки в базу работают по принципу ACID и можно делать rollback если что-то пошло не так. 

# Запросы к базе данных находятся отдельно в репозитории, постарался максимально оградить работы с базой от работы с бизнес-логикой - хотел показать что я это понимаю

## Почему Postgres

Потому что та задачи которое описано в тестовом задании более менее надежно можно решить с помощью Postgres. Остальное - либо очень бедные простые базы либо очень дорогие (для коммерческих целей) решения такие как Oracle или Microsoft SQL Server. NoSQL базы хоть и поддерживают но чтоб сделать подобное решение надо сильно больше кода писать и они не будут такими быстрыми как Postgres.

## Что сделано

GET /item
1. делает два запроса в https://api.skinport.com/items и берет оттуда список с tradable=true и потом список с tradable=false
2. мерджит два массива в один и возвращает так как описано в тестовом задании
3. при возврате записывает в кеш (можно редис но я сделал кеш через встроенный Map() с TTL 15мин ведь меньше зависимостей - это круто, но можно любой inmemory кеш, если надо - прикручу)


POST /purchase
1. Берет нужные параметры с body  (userId, itemId, idempotencyKey)
2. Проверяет оперделенные параметры и отправляет в репозиторий по работе с базой данных
3. Репозиторий делает транзакцию и записывает в историю покупок. Пользователь не может уйти в минус потому что CONSTRAINT balance_non_negative CHECK (balance_cents >= 0) и это самая низкоуровневая проверка/защита от подобных ситуаций
4. Возвращает результат операции
Присутсвие idempotencyKey не позволяет accedentally сделать несколько одинаковых покупок

GET /users
1. Показывает список пользователей и их баланс

GET /transactions
1. Показывает список транзакций


## Project setup


```bash
$ cp .env.example .env
$ docker-compose up -d --build
```

## Тесты Тесты Тесты


Когда есть Agentic coding - писать тесты руками я считаю рудиментарное занятие

Для unit тестов:
  docker compose exec app npm run test:unit

Для integration:
  docker compose exec app npm run test:integration
